- 单例模式
  - 饿汉模式：在声明时初始化；
  - 懒汉模式：在初次使用时初始化；
  - 两者比较
    - 通常选择懒汉模式，因为比较节省系统资源，当没有使用该类的对象时，不对其进行额外的初始化；
    - 问题：懒汉模式在多线程模式下不够安全，如何保证线程安全？
       - get方法上添加synchronized关键字，其问题在于该锁比较浪费资源，一次只能有一个线程进入该方法；
       - 改变synchronized的位置，只有在新建时需要初始化，因此当判断该类的实例不存在时才进入synchronized进行初始化；但该方法的存在线程安全的问题，new分为3
       步：堆上开辟空间、初始化值、栈上的引用指向堆，当这三步被指令重排时，在未初始化完成时，其引用已经指向堆上的空间，会导致存在空指针异常。
       - 将成员变量设置为volatile
       - 基于静态子类
       - 基于枚举类
- 二维数组的查找
   - 右上角的数字：横着最大、竖着最小，先比较与target的大小，决定横着找还是竖着找；
- 字符串空格替换
- 从尾到头打印链表
  - 递归或堆栈
```
public static void reversePrintList(Node list){
        if(list!=null){
            reversePrintList(list.next);
            System.out.println(list.value);
        }
    }
```
- 重建二叉树
  - 前序遍历和中序遍历
- 用两个栈实现队列
